{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OMOP_Semantic","text":"<p>omop_semantics is a lightweight, schema-backed registry for defining and managing semantic OMOP conventions. </p> <p>It provides a small, explicit layer for defining, validating, grouping, and traversing OMOP concept identifier and grouping for use in clinical modelling, phenotyping, staging systems, modifiers, and domain-specific semantics.</p> <p>This creates a validatable, versionable source that can integrate with ETL pipelines, data quality checks, and documentation generation systems, ensuring all of these convention-defining systems are guaranteed to be in sync.</p>"},{"location":"#what-problem-this-solves","title":"What problem this solves","text":"<p>A core design goal is to support opinionated, use-case\u2013specific schemas. Rather than assuming a single \u201ccorrect\u201d interpretation of the OMOP CDM, omop_semantics allows you to define and validate different convention profiles depending on context. This makes it possible to express constraints and semantics that are meaningful in one analytical setting but inappropriate or overly restrictive in another.</p> <p>For example, the OMOP CONDITION_OCCURRENCE table permits any standard concept from the condition domain. However, when working within an oncology-specific modelling context, additional semantic conventions often apply e.g how staging concepts and modifiers should be linked to malignant conditions, or which subsets of condition concepts are valid for tumour phenotyping. These oncology-specific conventions are not intrinsic to OMOP itself and are not generally applicable outside that domain. omop_semantics provides a structured way to encode, validate, and reason over these kinds of domain-specific conventions without baking them into the underlying CDM.</p> <p>In this sense, it is designed to act as a semantic control layer over OMOP: project-scoped, explicit, and explainable, while remaining portable and independent of the database or vocabulary services.</p> <ul> <li>Human-authored \u2013 concepts and groups are defined into roles and classes within LinkML schemas, which can be navigated to understand the explicit and inspectable semantic relationships</li> <li>Portable \u2013 no database or graph store required</li> <li>Versionable \u2013 definitions can be traced over time as conventions adapt to the needs of real-world data</li> <li>Flexible integrations - can be used to produce simple sql definitions, human-readable documentation, and OMOP-alchemy compatible vocabulary lookups</li> </ul>"},{"location":"#core-design","title":"Core design","text":"Layer What it is Examples A. Semantic primitives What does this concept mean in OMOP terms? <code>OmopConcept</code>, <code>OmopGroup</code>, <code>OmopEnum</code> B. Structural templates How does this semantic thing get written into CDM rows? <code>OmopTemplate</code> C. Registry / organisation How do we group and publish reusable definitions? <code>RegistryFragment</code>, <code>RegistryGroup</code> D. CDM profiles What shape of CDM row are we writing? <code>observation_coded</code>, <code>measurement_numeric</code>, etc flowchart TD     %% Core composition flow     RG[\"RegistryGroup\\n(organisational grouping of templates)\"]     TPL[\"OmopTemplate\\n(binds meaning to CDM shape)\"]      SEM[\"OmopSemanticObject\\n(Concept / Group / Enum)\"]     CDM[\"OmopCdmProfile\\n(table + slots)\"]      RG --&gt;|contains| TPL      TPL --&gt;|entity_concept / value_concept| SEM     TPL --&gt;|cdm_profile| CDM      %% Styling     classDef registry fill:#eef7ff,stroke:#3b82f6,stroke-width:1px;     classDef template fill:#f0fdf4,stroke:#22c55e,stroke-width:1px;     classDef semantic fill:#fff7ed,stroke:#f97316,stroke-width:1px;     classDef cdm fill:#fdf2f8,stroke:#ec4899,stroke-width:1px;      class RG registry     class TPL template     class SEM semantic     class CDM cdm   <ul> <li>OmopConcept   \u2192 atomic OMOP concept_id</li> <li>OmopGroup     \u2192 semantic sets of concepts</li> <li>OmopTemplate  \u2192 how concepts are composed into CDM rows</li> </ul> <p>At a high level, omop_semantics does four things:</p> <ol> <li>Loads a LinkML schema</li> </ol> <p>This defines:</p> <ul> <li>Valid semantic roles &amp; their definitions (e.g. staging, modifier, demographic)</li> <li> <p>Expected classes (e.g. OmopConcept, ConceptGroup)</p> </li> <li> <p>Loads YAML instance files</p> </li> </ul> <p>These define:</p> <ul> <li>Individual OMOP concepts with semantic roles and optional parents</li> <li> <p>Named groups of concepts (e.g. \u201cDemographyConcepts\u201d, \u201cTStage\u201d)</p> </li> <li> <p>Builds a runtime ConceptRegistry</p> </li> </ul> <p>The registry provides:</p> <ul> <li>Fast lookup by concept_id and role</li> <li>Group membership queries</li> <li>Semantic parent/ancestor traversal</li> <li> <p>Validation against the schema</p> </li> <li> <p>Supports round-tripping</p> </li> </ul> <p>The registry can be emitted back to LinkML-compatible YAML, enabling:</p> <ul> <li>Curation workflows</li> <li>Version control of semantic registries</li> <li>Programmatic transformation and merging</li> </ul>"},{"location":"#typical-usage","title":"Typical Usage","text":"<pre><code>from omop_semantics.utils.load import load\n\nregistry = load(\n    schema_paths=[\"omop_semantic_core.yaml\", \"staging.yaml\"],\n    instance_paths=[\"demographic.yaml\", \"staging_instances.yaml\"],\n)\n\nregistry.by_role(\"demographic\")\nregistry.ancestors_of(1634213)  # e.g. T0 \u2192 staging parents\nregistry.group_members(\"TStage\")\n</code></pre>"},{"location":"registry/","title":"Registry Runtime","text":"<p>This page documents the core runtime classes used to compile and apply OMOP semantic templates in ETL pipelines.</p>"},{"location":"registry/#omopsemanticengine","title":"OmopSemanticEngine","text":"<p>High-level entry point for working with OMOP semantic registries and profiles.</p> <p>This class wires together:   - the semantic resolver (concept/group/enum \u2192 OMOP concept_ids),   - the template compiler runtime,   - the registry runtime (indexed, compiled templates),   - and the optional semantic profile runtime (symbolic/profile view).</p> <p>It is intended to be the main object used by ETL pipelines, query builders, and documentation/rendering layers.</p> <p>Construct a semantic engine from an already-loaded registry fragment.</p> <p>Parameters:</p> Name Type Description Default <code>registry_fragment</code> <code>RegistryFragment</code> <p>Declarative registry fragment defining OMOP semantic templates and groups.</p> required <code>profile_objects</code> <code>dict[str, dict] | None</code> <p>Optional mapping of symbolic profile objects (e.g. OmopTemplate, OmopGroup, OmopConcept definitions) used for documentation and inspection.</p> <code>None</code>"},{"location":"registry/#omop_semantics.runtime.OmopSemanticEngine.docs_html","title":"docs_html","text":"<pre><code>docs_html() -&gt; Html\n</code></pre> <p>Render combined HTML documentation for the registry and profiles.</p> <p>Returns:</p> Type Description <code>Html</code> <p>HTML block containing registry tables and (if available) profile documentation.</p>"},{"location":"registry/#omop_semantics.runtime.OmopSemanticEngine.from_instances","title":"from_instances  <code>classmethod</code>","text":"<pre><code>from_instances(fragment: RegistryFragment) -&gt; OmopSemanticEngine\n</code></pre> <p>Construct a semantic engine directly from an in-memory RegistryFragment.</p> <p>This is useful in tests or programmatic composition of registry fragments.</p> <p>Parameters:</p> Name Type Description Default <code>fragment</code> <code>RegistryFragment</code> <p>Registry fragment containing semantic templates.</p> required <p>Returns:</p> Type Description <code>OmopSemanticEngine</code> <p>Initialised semantic engine.</p>"},{"location":"registry/#omop_semantics.runtime.OmopSemanticEngine.from_yaml_paths","title":"from_yaml_paths  <code>classmethod</code>","text":"<pre><code>from_yaml_paths(registry_paths: Iterable[Path], profile_paths: Iterable[Path] = ()) -&gt; OmopSemanticEngine\n</code></pre> <p>Construct a semantic engine from YAML registry and profile files.</p> <p>Multiple registry fragments are merged into a single runtime registry. Profile YAML files are loaded and merged into a single symbolic profile namespace for documentation and inspection.</p> <p>Parameters:</p> Name Type Description Default <code>registry_paths</code> <code>Iterable[Path]</code> <p>Paths to registry fragment YAML files.</p> required <code>profile_paths</code> <code>Iterable[Path]</code> <p>Optional paths to profile/symbol YAML files.</p> <code>()</code> <p>Returns:</p> Type Description <code>OmopSemanticEngine</code> <p>Initialised semantic engine with merged registry and profiles.</p>"},{"location":"registry/#omopregistryruntime","title":"OmopRegistryRuntime","text":"<p>Runtime interface over a registry of OMOP semantic templates.</p> <p>This class provides indexed, compiled access to a RegistryFragment, allowing templates to be retrieved by name, grouped by role, or iterated over in compiled form for use in ETL pipelines and semantic execution layers.</p> <p>Compilation is cached to avoid repeated semantic resolution and to provide stable runtime objects during pipeline execution.</p> <p>Initialise the registry runtime for a semantic registry fragment.</p> <p>Parameters:</p> Name Type Description Default <code>fragment</code> <code>RegistryFragment</code> <p>Registry fragment containing declarative OMOP semantic templates.</p> required <code>template_runtime</code> <code>OmopTemplateRuntime</code> <p>Compiler used to convert templates into execution-ready form.</p> required"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.roles","title":"roles  <code>property</code>","text":"<pre><code>roles: Set[str]\n</code></pre> <p>Get the set of all semantic roles defined in the registry.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Unique set of semantic roles (e.g. 'demographic', 'staging') present in the registry.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.template_names","title":"template_names  <code>property</code>","text":"<pre><code>template_names: Set[str]\n</code></pre> <p>Get the set of all template names defined in the registry.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Unique set of template names present in the registry.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.by_role","title":"by_role","text":"<pre><code>by_role(role: str) -&gt; list[CompiledTemplate]\n</code></pre> <p>Retrieve all compiled templates for a given semantic role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str</code> <p>Semantic role to filter by (e.g. 'demographic', 'staging').</p> required <p>Returns:</p> Type Description <code>list[CompiledTemplate]</code> <p>List of compiled templates associated with the given role.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.compile_all","title":"compile_all","text":"<pre><code>compile_all(role: str | None = None) -&gt; list[CompiledTemplate]\n</code></pre> <p>Retrieve all compiled templates, optionally filtered by role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str | None</code> <p>Optional semantic role to filter templates.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CompiledTemplate]</code> <p>List of compiled templates in the registry.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.compile_index","title":"compile_index","text":"<pre><code>compile_index() -&gt; None\n</code></pre> <p>Compile and index all templates in the registry.</p> <p>This method resolves all semantic objects and caches the compiled templates for fast lookup by name or role during runtime execution.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.get","title":"get","text":"<pre><code>get(name: str) -&gt; CompiledTemplate\n</code></pre> <p>Retrieve a compiled template by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the semantic template.</p> required <p>Returns:</p> Type Description <code>CompiledTemplate</code> <p>Compiled representation of the named template.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no template with the given name exists.</p> <code>RuntimeError</code> <p>If compilation has failed.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.iter_templates","title":"iter_templates","text":"<pre><code>iter_templates(role: str | None = None)\n</code></pre> <p>Iterate over declarative templates in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str | None</code> <p>Optional semantic role to filter templates (e.g. 'demographic').</p> <code>None</code> <p>Yields:</p> Type Description <code>OmopTemplate</code> <p>Declarative semantic templates from the registry.</p>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.to_compiled_html","title":"to_compiled_html","text":"<pre><code>to_compiled_html(role: str | None = None) -&gt; Html\n</code></pre> <p>Render the compiled registry as an HTML table.</p> <p>This view displays the execution-ready form of semantic templates, where semantic objects have been resolved to concrete OMOP concept IDs. It is useful for inspecting the concrete OMOP mappings that will be used by ETL pipelines or query builders.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str | None</code> <p>Optional semantic role to filter compiled templates. If provided, only compiled templates with this role are rendered.</p> <code>None</code> <p>Returns:</p> Type Description <code>Html</code> <p>HTML representation of the compiled templates suitable for display in Jupyter or documentation.</p> <p>Examples:</p> <p>Inspect the compiled demographic mappings:</p> <pre><code>&gt;&gt;&gt; engine.registry_runtime.to_compiled_html(role=\"demographic\")\n</code></pre> <p>Compare declarative vs compiled views:</p> <pre><code>&gt;&gt;&gt; engine.registry_runtime.to_html()\n&gt;&gt;&gt; engine.registry_runtime.to_compiled_html()\n</code></pre>"},{"location":"registry/#omop_semantics.runtime.OmopRegistryRuntime.to_html","title":"to_html","text":"<pre><code>to_html(role: str | None = None) -&gt; Html\n</code></pre> <p>Render the declarative registry fragment as an HTML table.</p> <p>This view displays the semantic templates grouped by registry group, showing their role, CDM profile, and associated semantic objects (entity and value concepts). It is intended for documentation, debugging, and interactive exploration in notebooks.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str | None</code> <p>Optional semantic role to filter templates (e.g. 'demographic', 'staging'). If provided, only templates with this role are rendered.</p> <code>None</code> <p>Returns:</p> Type Description <code>Html</code> <p>HTML representation of the registry suitable for display in Jupyter.</p> <p>Examples:</p> <p>Render the full registry in a notebook:</p> <pre><code>&gt;&gt;&gt; engine.registry_runtime.to_html()\n</code></pre> <p>Render only demographic templates:</p> <pre><code>&gt;&gt;&gt; engine.registry_runtime.to_html(role=\"demographic\")\n</code></pre>"},{"location":"registry/#runtimetemplate","title":"RuntimeTemplate","text":"<p>Attribute-based runtime view over a compiled OMOP template.</p> <p>This is a thin wrapper around CompiledTemplate to provide ergonomic access in ETL pipelines and execution code.</p>"},{"location":"registry/#omoptemplateruntime","title":"OmopTemplateRuntime","text":"<p>Runtime compiler for OMOP semantic templates.</p> <p>This class transforms declarative OmopTemplate instances into compiled, execution-ready representations by resolving semantic objects into concrete OMOP concept identifiers using an OmopSemanticResolver.</p> <p>The output of this layer is intended to be consumed directly by ETL pipelines, query builders, or analytics workflows.</p> <p>Create a runtime compiler bound to a semantic resolver.</p> <p>Parameters:</p> Name Type Description Default <code>resolver</code> <code>OmopSemanticResolver</code> <p>Resolver used to ground semantic objects into OMOP concept IDs.</p> required"},{"location":"registry/#omop_semantics.runtime.OmopTemplateRuntime.compile","title":"compile","text":"<pre><code>compile(tpl: OmopTemplate) -&gt; CompiledTemplate\n</code></pre> <p>Compile a declarative OMOP template into a runtime representation.</p> <p>Parameters:</p> Name Type Description Default <code>tpl</code> <code>OmopTemplate</code> <p>Declarative semantic template describing how concepts map to OMOP CDM slots.</p> required <p>Returns:</p> Type Description <code>CompiledTemplate</code> <p>Execution-ready representation of the template, with resolved concept IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the template is missing required semantic components.</p>"},{"location":"registry/#omopsemanticresolver","title":"OmopSemanticResolver","text":"<p>Resolves OMOP semantic objects into concrete OMOP concept identifiers.</p> <p>This class provides the semantic grounding layer between declarative semantic objects (e.g. OmopConcept, OmopGroup, OmopEnum) and the executable representation required by OMOP-based ETL and query logic.</p> <p>The resolver is intentionally minimal and explainable: - OmopConcept resolves to its single concept_id - OmopEnum resolves to the set of concept_ids of its members - OmopGroup resolves to the anchor (parent) concept_ids of the group</p> <p>This library is not database-backed so the resolved group hierarchies need to be resolved in downstream logic.</p> <p>TODO: allow this class to extended with full resolution logic without introducing dependencies on database connections or external services.</p>"},{"location":"registry/#omop_semantics.runtime.OmopSemanticResolver.resolve","title":"resolve","text":"<pre><code>resolve(obj: OmopSemanticObject) -&gt; set[int]\n</code></pre> <p>Resolve a semantic object into a set of OMOP concept identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>OmopSemanticObject</code> <p>A semantic object describing permissible OMOP concepts.</p> required <p>Returns:</p> Type Description <code>set[int]</code> <p>A set of OMOP concept_ids derived from the semantic object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a required concept_id is missing.</p> <code>TypeError</code> <p>If the semantic object type is unsupported.</p>"},{"location":"registry/#semanticprofileruntime","title":"SemanticProfileRuntime","text":"<p>Runtime interface over semantic profile objects.</p> <p>This class provides lightweight, read-only access to profile-layer semantic objects (e.g. RegistryGroup, OmopTemplate, OmopGroup, OmopConcept) loaded from profile YAML files. It is primarily intended for documentation, inspection, and UI / notebook exploration rather than execution-time ETL logic.</p> <p>Initialise the profile runtime.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>dict[str, dict] | list[dict[str, dict]]</code> <p>Mapping of profile object names to raw profile dictionaries, or a list of such mappings (which will be merged). Later entries take precedence when merging.</p> required"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.explain","title":"explain","text":"<pre><code>explain(name: str) -&gt; str\n</code></pre> <p>Return a short human-readable explanation for a profile object.</p> <p>This is typically sourced from the <code>notes</code> field in the profile definition and is intended for UI / documentation display.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the profile object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Notes or description associated with the object, or a fallback message if none is provided.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no profile object with the given name exists.</p>"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.explain_html","title":"explain_html","text":"<pre><code>explain_html(name: str) -&gt; Html\n</code></pre> <p>Render a single profile object as a simple key/value HTML table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the profile object to explain.</p> required <p>Returns:</p> Type Description <code>Html</code> <p>Rendered HTML block showing all fields on the object.</p>"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.get","title":"get","text":"<pre><code>get(name: str) -&gt; dict\n</code></pre> <p>Retrieve a profile object by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the profile object.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Raw profile object dictionary.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no profile object with the given name exists.</p>"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.list_groups","title":"list_groups","text":"<pre><code>list_groups() -&gt; dict[str, dict]\n</code></pre> <p>List all RegistryGroup objects defined in the profiles.</p> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of group name to raw RegistryGroup profile dictionaries.</p>"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.list_semantic_objects","title":"list_semantic_objects","text":"<pre><code>list_semantic_objects() -&gt; dict[str, dict]\n</code></pre> <p>List all semantic objects (OmopGroup, OmopConcept, OmopEnum) defined in the profiles.</p> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of object name to raw profile dictionaries for semantic objects.</p>"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.list_templates","title":"list_templates","text":"<pre><code>list_templates() -&gt; dict[str, dict]\n</code></pre> <p>List all OmopTemplate objects defined in the profiles.</p> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Mapping of template name to raw OmopTemplate profile dictionaries.</p>"},{"location":"registry/#omop_semantics.runtime.SemanticProfileRuntime.to_html","title":"to_html","text":"<pre><code>to_html() -&gt; Html\n</code></pre> <p>Render all loaded semantic profile objects as HTML documentation.</p> <p>This produces a lightweight, human-readable overview of: - Registry groups - Templates - Semantic objects (groups, concepts, enums)</p> <p>Returns:</p> Type Description <code>Html</code> <p>Rendered HTML block suitable for notebook display.</p>"},{"location":"usage/","title":"e2e Use of OMOP Semantic Registry in ETL","text":""},{"location":"usage/#what-are-we-doing","title":"What are we doing?","text":"<p>Defining in a structured way what conventions look like so that it is machine ingestable and therefore testable and can be added into ETL pipeline hooks.</p> <p>Load registry &amp; profiles</p> <pre><code>from pathlib import Path\nfrom omop_semantics.runtime import OmopSemanticEngine, RegistryFragment\nfrom omop_semantics.runtime.instance_loader import load_registry_fragment, load_profiles, load_symbol_module\nfrom linkml_runtime.loaders import yaml_loader\nfrom omop_semantics import SCHEMA_DIR, INSTANCE_DIR\n\n\ninstance_base = INSTANCE_DIR\nprofile_base = SCHEMA_DIR / \"profiles\"\n\nengine = OmopSemanticEngine.from_yaml_paths(\n    registry_paths=[\n        instance_base / \"demography.yaml\",\n        instance_base / \"registry/staging.yaml\",\n    ],\n    profile_paths=[\n        profile_base / \"omop_profiles.yaml\",\n    ],\n)\n</code></pre> <p>Example: Design-time</p> <p>This specifies that if you are looking for a valid location for country of birth, you need to use the observation_simple template and select for child concepts of <code>4155450</code></p> <pre><code>      name: Country of birth\n      role: demographic\n      entity_concept:\n        name: Country of Birth\n        class_uri: OmopGroup\n        parent_concepts:\n        - concept_id: 4155450\n          label: Country of birth\n      cdm_profile: observation_simple\n</code></pre> <p>Cross-referencing against the available profiles, we see that the <code>observation_simple</code> template does not use the <code>value_as</code> fields, populating instead the <code>observation_concept_id</code> field directlly.</p> <pre><code>profiles:\n  - name: observation_simple\n    cdm_table: observation\n    concept_slot: observation_concept_id\n</code></pre> <p>Example: Run-time resolution</p> <p>Note that we do not want to be either</p> <ol> <li>redefining full classes for simple data structures that conform exactly to the defined profiles, or</li> <li>having to repeat full profiles in registry fragments. </li> </ol> <p>Instead, we have a pre-processing step that merges instance files with profiles to create a \"registry fragment\" that can be used to initialise the resolver</p> <p><pre><code>profiles = load_profiles(instance_base / \"profiles.yaml\")\n\nregistry_dict = merge_instance_files(\n    paths = [instance_base / \"demographic.yaml\"],\n    profiles = profiles\n)\n</code></pre> On initial load, we just get a reference to the template as a string, which does not conform to the template structure in its own right...</p> <pre><code>yaml_loader.load_as_dict(f'{instance_base / \"demographic.yaml\"}')['groups'][0]['registry_members'][0]\n\n# {'name': 'Country of birth',\n#  'role': 'demographic',\n#  'entity_concept': {'name': 'Country of Birth',\n#   'class_uri': 'OmopGroup',\n#   'parent_concepts': [{'concept_id': 4155450, 'label': 'Country of birth'}]},\n#  'cdm_profile': 'observation_simple'}\n</code></pre> <p>after we apply the profiles, we get a fully conformed registry fragment with all the relevant information from the profile</p> <pre><code>profiles['observation_simple']\n\n# OmopCdmProfile(name='observation_simple', cdm_table='observation', concept_slot='observation_concept_id', value_slot=None)\n</code></pre> <p>this structure can now be used to properly instantiate the template classes and then fully used for rendering, validation, etc. downstream</p> <pre><code>registry_dict['groups'][0]['registry_members'][0]\n\n{'name': 'Country of birth',\n 'role': 'demographic',\n 'entity_concept': {'name': 'Country of Birth',\n  'class_uri': 'OmopGroup',\n  'parent_concepts': [{'concept_id': 4155450, 'label': 'Country of birth'}]},\n 'cdm_profile': {'name': 'observation_simple',\n  'cdm_table': 'observation',\n  'concept_slot': 'observation_concept_id',\n  'value_slot': None}}\n</code></pre> <p>other more complex modules can be created as full linkml subschemas and then loaded directly instead</p> <pre><code>staging_symbols = load_symbol_module(profile_base / 'omop_staging.yaml')\nmodifier_symbols = load_symbol_module(profile_base / 'omop_modifiers.yaml')\n\nstaging_symbols['TStageConcepts']\n\n# {'is_a': 'RegistryGroup',\n#  'name': 'TStageConcepts',\n#  'role': 'staging',\n#  'registry_members': ['T0', 'T1', 'T2', 'T3', 'T4', 'Ta', 'Tis', 'TX']}\n\nstaging_symbols['T0']\n\n# {'class_uri': 'OmopGroup',\n#  'parent_concepts': [{'concept_id': 1634213, 'label': 'T0'}],\n#  'role': 'staging'}\n\nregistry_fragment = yaml_loader.load(\n    registry_dict,\n    target_class=RegistryFragment\n)\n\nengine = OmopSemanticEngine(\n    registry_fragment=registry_fragment,\n    profile_objects=[staging_symbols, modifier_symbols]   # or merge with profile symbols too\n)\n</code></pre> <p>Now that our engine is fully instantiated...</p> <pre><code>tpl = engine.registry_runtime.get_runtime(\"Country of birth\")\ntpl.entity_concept_ids\n# {4155450}\n</code></pre> <p>Example: ETL-time compiled templates</p> <p>Example ETL routing logic:</p> <pre><code>def emit_row_from_template(\n    tpl: RuntimeTemplate,\n    *,\n    concept_id: int,\n    value: str | int | None,\n    person_id: int,\n    date: str,\n) -&gt; tuple[str, dict]:\n    \"\"\"\n    Emit an OMOP CDM row driven entirely by the template's CDM profile.\n\n    Returns (cdm_table_name, row_dict)\n    \"\"\"\n    profile = tpl.cdm_profile\n\n    row: dict[str, object] = {\n        profile.concept_slot: concept_id,\n        \"person_id\": person_id,\n        \"observation_date\": date,   # date handling could also be driven by profile later if needed\n    }\n\n    if profile.value_slot:\n        row[profile.value_slot] = value\n\n    return profile.cdm_table, row\n\n\ntpl = engine.registry_runtime.get_runtime(\"Postcode\")\n\n# tpl.cdm_profile.name == \"observation_string\"\n\ntable, row = emit_row_from_template(\n    tpl,\n    concept_id=4083591,  # Postcode concept\n    value=\"2031\",\n    person_id=123,\n    date=\"2024-01-01\",\n)\n\ntable\n# \"observation\"\n\nrow\n# {\n#   \"observation_concept_id\": 4083591,\n#   \"value_as_string\": \"2031\",\n#   \"person_id\": 123,\n#   \"observation_date\": \"2024-01-01\"\n# }\n\ntpl = engine.registry_runtime.get_runtime(\"Language spoken\")\n# profile: observation_coded\n\n\ntable, row = emit_row_from_template(\n    tpl,\n    concept_id=4052785,     # \"Language spoken\"\n    value=4182347,         # \"English\"\n    person_id=123,\n    date=\"2024-01-01\",\n)\n\nrow\n# {\n#   \"observation_concept_id\": 4052785,\n#   \"value_as_concept_id\": 4182347,\n#   \"person_id\": 123,\n#   \"observation_date\": \"2024-01-01\"\n# }\n</code></pre>"},{"location":"valuesets/","title":"Value Sets Runtime","text":""},{"location":"valuesets/#runtimevaluesets","title":"RuntimeValueSets","text":"<p>Top-level runtime namespace for all compiled value sets.</p> <p>This is the primary entry point for interactive access to the semantic registry:</p> <pre><code>&gt;&gt;&gt; runtime.genomic\n&gt;&gt;&gt; runtime.staging\n&gt;&gt;&gt; runtime.nlp\n</code></pre> <p>Each attribute corresponds to a named <code>RuntimeValueSet</code>.</p>"},{"location":"valuesets/#runtimevalueset","title":"RuntimeValueSet","text":"<p>Runtime representation of a named value set.</p> <p>A value set groups multiple semantic units under a single namespace or  conceptual module - no added functionality just for ease of access and use</p> <p>(e.g. <code>genomic</code>, <code>staging</code>, <code>modifiers</code>).</p> <p>Semantic units can be accessed via attribute lookup:</p> <pre><code>&gt;&gt;&gt; runtime.genomic.genomic_value_group\nRuntimeSemanticUnit(...)\n</code></pre>"},{"location":"valuesets/#runtimesemanticunit","title":"RuntimeSemanticUnit","text":"<p>Runtime container for a single semantic unit.</p> <p>A semantic unit may contain any combination of:</p> <ul> <li>Named enums (<code>RuntimeEnum</code>)</li> <li>Named groups (<code>RuntimeGroup</code>)</li> <li>Named concepts (raw <code>OmopConcept</code>)</li> </ul> <p>This class exposes:</p> <ul> <li>Direct access to named enums/groups/concepts via attributes</li> <li>Direct access to enum/group labels as attributes (flattened lookup)</li> <li>Rich textual and HTML representations for introspection</li> </ul> Example <pre><code>&gt;&gt;&gt; runtime.genomic.genomic_value_group.genomic_positive\n9191\n\n&gt;&gt;&gt; runtime.staging.t_stage_concepts.t4\n1634654\n</code></pre>"},{"location":"valuesets/#runtimeenum","title":"RuntimeEnum","text":"<p>               Bases: <code>_RuntimeLabelledConcepts</code></p> <p>Runtime wrapper around an <code>OmopEnum</code>.</p> <p>Exposes enum members as a label to concept_id mapping, accessible via attribute access:</p> <pre><code>&gt;&gt;&gt; runtime.genomic.genomic_value_group.genomic_positive\n9191\n</code></pre> <p>Attributes:</p> Name Type Description <code>labels</code> <code>list[str]</code> <p>Sorted list of enum labels.</p> <code>ids</code> <code>list[int]</code> <p>Sorted list of concept IDs in the enum.</p>"},{"location":"valuesets/#runtimegroup","title":"RuntimeGroup","text":"<p>               Bases: <code>_RuntimeLabelledConcepts</code></p> <p>Runtime wrapper around an <code>OmopGroup</code>.</p> <p>Exposes the group's parent concepts as an attribute-accessible namespace, mapping concept labels to OMOP concept IDs. This allows interactive access such as:</p> <pre><code>&gt;&gt;&gt; runtime.staging.t_stage_concepts.t3\n1634376\n</code></pre>"},{"location":"valuesets/#omop_semantics.runtime.value_sets.RuntimeGroup.value","title":"value  <code>property</code>","text":"<pre><code>value: int\n</code></pre> <p>Return the sole concept_id if this group has exactly one parent.</p>"},{"location":"valuesets/#omop_semantics.runtime.value_sets.RuntimeGroup.__int__","title":"__int__","text":"<pre><code>__int__() -&gt; int\n</code></pre> <p>Allow int(runtime.group) for singleton groups.</p>"},{"location":"valuesets/#compile_valuesets","title":"compile_valuesets","text":"<p>Compile declarative CDM value set definitions into runtime objects.</p> <p>Parameters:</p> Name Type Description Default <code>defs</code> <code>CDMValueSets</code> <p>Parsed value set definitions after interpolation.</p> required <p>Returns:</p> Type Description <code>RuntimeValueSets</code> <p>Runtime-accessible registry of all value sets and semantic units.</p> Notes <p>This step materialises the interactive runtime namespace used in notebooks and rule logic. It is intentionally pure and read-only.</p>"},{"location":"valuesets/#interpolate_valuesets","title":"interpolate_valuesets","text":"<p>Interpolate raw value set definitions by resolving string references.</p> <p>This replaces string references in <code>valuesets.yaml</code> with concrete <code>CDMSemanticUnits</code> instances wrapping the corresponding OMOP semantic objects.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>dict</code> <p>Raw parsed YAML dictionary from <code>valuesets.yaml</code>.</p> required <code>semantic_index</code> <code>dict[str, OmopSemanticObject]</code> <p>Lookup table mapping semantic unit names to OMOP semantic objects.</p> required <p>Returns:</p> Type Description <code>CDMValueSets</code> <p>Fully resolved value set definitions suitable for compilation into runtime objects.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a referenced semantic unit name does not exist.</p> <code>TypeError</code> <p>If an unsupported semantic object type is encountered.</p>"},{"location":"valuesets/#index_semantic_units","title":"index_semantic_units","text":"<p>Build a name \u2192 semantic object index from a <code>CDMSemanticUnits</code> container.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>CDMSemanticUnits</code> <p>Declarative semantic unit registry.</p> required <p>Returns:</p> Type Description <code>dict[str, OmopSemanticObject]</code> <p>Mapping from semantic unit name to underlying OMOP semantic object (enum, group, or concept).</p> <code>This index is used during interpolation of value set definitions.</code>"},{"location":"valuesets/#default_valuesets","title":"default_valuesets","text":""},{"location":"valuesets/#default-value-sets","title":"Default Value Sets","text":"<p>This module provides a reference implementation for loading and compiling the default OMOP semantic value sets shipped with the library.</p> <p>It demonstrates the full runtime loading pipeline:</p> <ol> <li>Loading semantic unit definitions (enums, groups, concepts) from YAML.</li> <li>Indexing semantic units by name.</li> <li>Loading high-level value set definitions.</li> <li>Interpolating string references into concrete semantic objects.</li> <li>Compiling the result into runtime-friendly accessors.</li> </ol> <p>This file is intended primarily as: - a working exemplar of the loading pipeline, and - a convenient import point for default registry semantics.</p>"},{"location":"valuesets/#loading-pipeline","title":"Loading Pipeline","text":"<p>The default value sets are constructed using the following steps:</p> <pre><code>from pathlib import Path\nfrom linkml_runtime.loaders import yaml_loader\n\nfrom omop_semantics.schema.generated_models.omop_named_sets import CDMSemanticUnits\nfrom omop_semantics.runtime.value_sets import (\n    compile_valuesets,\n    index_semantic_units,\n    interpolate_valuesets,\n    RuntimeValueSets,\n)\nfrom omop_semantics import SCHEMA_DIR, INSTANCE_DIR\n\nschema_path = SCHEMA_DIR / \"core\" / \"omop_named_sets.yaml\"\nenumerator_instances = INSTANCE_DIR / \"enumerators.yaml\"\nvalueset_definitions = INSTANCE_DIR / \"valuesets.yaml\"\n\n# Load semantic units (enums, groups, concepts)\nenumerators = yaml_loader.load(\n    str(enumerator_instances),\n    target_class=CDMSemanticUnits,\n)\n\n# Build name \u2192 semantic object index\nidx = index_semantic_units(enumerators)\n\n# Load valueset definitions (string references)\nvalue_sets = yaml_loader.load_as_dict(str(valueset_definitions))\n\n# Interpolate string references into concrete semantic units\nvalue_set_objects = interpolate_valuesets(value_sets, idx)\n\n# Compile to runtime objects\nruntime = compile_valuesets(value_set_objects)\n</code></pre>"},{"location":"valuesets/#intended-usage","title":"Intended Usage","text":"<p>This module is designed to be imported directly by downstream code (etl, interactive analytics, auto-documentation and/or data validation)</p> <pre><code>from omop_semantics.runtime.default_valuesets import runtime\n\nconcept_id = runtime.genomic.genomic_value_group.genomic_positive\n</code></pre> <p>It can also be used as a template for loading:</p> <ul> <li>site-specific value sets,</li> <li>project-specific semantic registries, or</li> <li>dynamically constructed semantic bundles.</li> </ul>"},{"location":"valuesets/#notes","title":"Notes","text":"<ul> <li>This loader pipeline is intentionally explicit and decomposed for clarity.</li> <li>The API surface may be wrapped in higher-level convenience functions in future versions.</li> <li>The current design prioritises transparency and inspectability over terseness.</li> </ul>"}]}